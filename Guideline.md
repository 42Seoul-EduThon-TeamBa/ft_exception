# ft_exception 문제 해설
## ex00: Heroes Never Die
### 왜 이런 제목인가요?
원래라면 비정상 종료될 프로세스를 시그널 핸들러를 교체함으로써 비정상 종료를 막아줄 수 있기 때문입니다. 교육생으로 하여금 이것이 마치 프로세스를 되살려주는 것 같은 느낌을 받았으면 했습니다.

### 비정상 종료는 왜 일어나나요?
유효하지 않은 포인터에 접근할 때 발생하는 Segmentation fault나 bus error는 시그널입니다.
아래와 같은 코드로 인해서 프로그램이 즉시 종료되는 것이 아니라, 시그널이 발생된 후에 시그널로 인해 프로그램이 종료됩니다.
```c
char *p = 42;
p[42] = '*';
```

### 프로세스를 어떻게 되살려줄 수 있나요?
대부분의 사례에서 SIGSEGV, SIGABRT, SIGBUS와 같은 terminate process 액션을 가지는 시그널이 발생했을 때 프로세스가 비정상적으로 종료되는 것이 일반적입니다. 이 액션이 기본값으로 등록되어 있기 때문입니다.
그런데 항상 꼭 그렇지만은 않습니다. signal 함수를 통해서 핸들러를 등록해준다면 시그널이 발생 했을 때의 액션을 사용자가 정의해줄 수도 있습니다.
이를 통해서 시그널이 발생하더라도 프로그램이 비정상적으로 종료되지 않도록 만들 수 있고, 사용자가 원하는 동작을 하도록 만들어줄 수도 있습니다.

### 그러면 이게 끝인가요?
시그널이 발생했을 때 시그널 핸들러가 끝나면 다시 원래의 흐름으로 돌아와 아무 일도 일어나지 않았던것 처럼 이어집니다. 이렇게 시그널을 등록하는 것만으로도 비정상 종료를 피하게 되므로 사용자는 마치 오류를 모두 복구한듯한 느낌을 받을 수도 있습니다.
하지만 이것만으로는 부족합니다. 이렇게만 한다면 아무런 오류가 일어나지 않았던 것과 같은 상황이 되어 진행될 것입니다. 오류를 제대로 복구하려면 오류를 복구하는 흐름이 있어야 합니다. 마치 C++의 try-catch 처럼요.

## ex01: Try Me
### 이제 무엇을 해야하나요?
오류 복구 혹은 해결 흐름을 시그널 핸들러에서 처리해도 물론 괜찮습니다. 하지만 시그널 내에서 복구가 끝나고나면 다시 원래의 흐름으로 그대로 돌아옵니다. 복원의 영향으로 원래의 흐름이 정상 작동하지 않는 상황도 발생할 수 있습니다. 아니면 복원할 수 없는 오류라서 원래의 흐름으로 돌아와도 똑같은 오류가 반복될 수도 있습니다. 이렇게 되면 결국 다시 시그널 핸들러로 돌아오는 일을 무한히 반복하게 될테니, 자연스럽게 정상적인 흐름과 오류의 흐름의 분리가 필요하게 됩니다.

### 흐름을 분리할 수가 있나요?
POSIX에서는 <setjmp.h> 라이브러리를 통해서 비지역(local)적으로 흐름을 이동할 수 있는 방법을 제공합니다.
setjmp 함수를 사용해서 스택 포인터 등을 포함한 레지스터가 있는 스레드 콘텍스트를 특정 메모리 위치에 백업해두고, longjmp 함수를 사용해서 백업해둔 스레드 콘텍스트로 되돌아갈 수 있습니다. 이는 마치 스택이 되돌아가는 것 같은 효과를 내줍니다. 결국 C++의 exception 작동 원리와 매우 유사하게 작동하도록 할 수 있습니다.

### 왜 setjmp는 허용 함수가 아닌가요?
먼저 setjmp-longjmp 쌍에서 longjmp를 사용해볼 수 있도록 문제를 구성했습니다. 비록 궁극적으로는 longjmp를 조사하면서 setjmp도 함께 살펴 보아야만 하겠지만, 특히 하나의 구현에만 집중할 수 있는 환경을 조성해주고자 했습니다.

### 무엇을 하면 되나요?
ex00에서는 SIGFPE가, ex01에서는 SIGSEGV가 발생하는 경우의 예시 코드를 제공했습니다. 이를 활용해서 해당 시그널을 핸들링하고, 시그널 핸들러에 있는 시그널 번호를 longjmp를 통해 되돌려주면 됩니다.

## ex02: Catch Me
이제 위에서 익힌 모든 것을 직접 만들어볼 시간입니다.
ex00과 ex01에서 학습한 내용만으로도 충분히 try-catch 구문처럼 작동하게 만들 수 있습니다.

### 만약 oldchar과 newchar가 같다면?
str에 접근하기 전에 oldchar과 newchar가 같은 경우는 아무런 일도 하지 않도록 만들 수도 있습니다. 그래서 이런 경우는 테스트 케이스에 포함되지 않습니다.

## Extra
 - raise() 함수를 사용하여 throw에 대응되는 기능 만들어보기.
 - backtrace() 함수와 addr2line을 이용하여 StackTrace 기능 만들어보기.
 - 전처리기 매크로를 정의하여 try, catch, finally, throw 키워드 만들어보기.
